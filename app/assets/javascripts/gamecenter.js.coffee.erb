class window.GameCenterCls
    entry_id: 0
    my_total_score: 0
    entry: {}
    contest: {}
    lineup: {}
    lineup_spots: []
    players: {}

    my: {}

    pusher: null

    stat_names: ['points', 'assists', 'steals', 'rebounds', 'blocks', 'turnovers']
    stat_rules:
        points: 1
        assists: 1.5
        steals: 2
        rebounds: 1.25
        blocks: 2
        turnovers: -1

    handlePushedStats: (data) ->
        # handle stats received from Pusher(). We only receive stats that have changed. Update the
        # client-side player entry with the data.
        context = this
        console.log (data)
        $(data.players).each( (index, player) ->
            context.players[player.id].stats[player.stat_name] = player.stat_value
            context.update_lineup_player(context.players[player.id])
        )

    constructor: ->
        that = @

        console.log "GameCenter Constructor"
        this.pusher = new Pusher('<%= Rails.env.development? ? "86296472974842e38cce" : Pusher.key %>')
        this.setEntryID($('.gamecenter').data('entry_id'))
        console.log(this.entry_id)
        this.getData()

        channel = this.pusher.subscribe('gamecenter')

        channel.bind('stats',  (data) -> that.handlePushedStats(data) )
        $("table.freeroll tr").click (e) ->
            # user clicked on one of the users in top row. Get its entry id, populate that same entry ID
            # in the competitive scorecard, and then get the data for the scorecard from server.
            entryid = $(e.currentTarget).data("entry-id")
            console.log(e)
            console.log(entryid)
            $("#competitor-scorecard").attr("data-entry-id", entryid).hide()

            $.ajax(
                method: "GET"
                url: "/api/gc_data/" + entryid
                context: that
            ).success( (data, status, headers, config) ->
                this.handleAjaxData(data, status, headers, config)
            ).error (data, status, headers, config) ->
                console.log('error')


    setEntryID: (entry_id) ->
        this.entry_id = entry_id

    update_lineup_player: (player) ->

        # got a player instance to update on the UI. Find matching rows (there could be more than
        # 1) and change their HTML.
        context = this
        $(".scorecard tr[data-player-id=" + player.id + "]").each( (index, scorecardrow) ->
            $(scorecardrow).find('.player-name').html(player.first_name + " " + player.last_name)
            $(scorecardrow).find('.salary').html(player.salary)
            $(scorecardrow).find('.score').html(player.stats['fp'])
            records = []
            # fill out the detailed stats ("0 P 1 A ...")
            $(context.stat_names).each((i, stat_name) ->
                txt = player.stats[stat_name] + " " + stat_name.charAt(0)
                records.push(txt)
            )
            $(scorecardrow).find('.records').html(records.join(', '))
        )

    refreshMyLineup: (data) ->
        # update scorecard using data received from server.
        scorecard_to_update = $(".scorecard[data-entry-id=" + data.entry.id + "]")
        scorecard_tbody = scorecard_to_update.find("tbody")
        $(scorecard_to_update).find(".username").html(data.my.username)
        $(scorecard_to_update).find(".total-score").html(data.curr_fp)

        # remove the table rows before refreshing.
        $(scorecard_tbody.find("tr")).each(->
            $(this).remove()
        )
        this.data = data
        context = this
        $(context.data.lineup_spots).each((index, lineup_spot) ->
            # Build each row in the scorecard and attach it to DOM.

            scorecardrow = $('tr.lineup-row-template').clone() \
                .removeClass('lineup-row-template').attr("data-player-id", lineup_spot.player.id) \
                .appendTo(scorecard_tbody)
            $(scorecardrow).find('.role').html(lineup_spot.sport_position.name)
            context.update_lineup_player(context.players[lineup_spot.player.id], scorecardrow)

        )
        $(scorecard_to_update).show()

    getData: ->
        that = @
        $.ajax(
            method: "GET"
            url: "/api/gc_data/" + that.entry_id
            context: this
        ).success(
                this.handleAjaxData

        ).error (data, status, headers, config) ->
            console.log('error')

    handleAjaxData: (data, status, headers, config) ->
        #console.log(data)
        # save player data as a client-side model so it can be partially updated via realtime
        context = this
        $(data.lineup_spots).each((index, lineup_spot) ->
            context.players[lineup_spot.player.id] = lineup_spot.player

            # slight friction between AJAX and Pusher API -- stats is in lineup in AJAX, while
            # it's in "player" in the Pusher.
            context.players[lineup_spot.player.id].stats = lineup_spot.stats
        )
        this.refreshMyLineup(data)
        #this.entry = data.entry
        #this.contest = data.contest
        #this.lineup = data.lineup
        #this.lineup_spots = JSON.parse(JSON.stringify(data.lineup_spots));
        ## WAS this.lineup_spots = data.lineup_spots
        #this.my = data.my
        #this.refreshMyLineup(data)


$(document).on('page:load ready', ->
    if $('.gamecenter').length > 0
        window.gamecenter = new GameCenterCls
)
